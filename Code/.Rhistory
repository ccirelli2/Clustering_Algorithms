df.comp$comp.dist[df.comp$comp.dist == FALSE] <- 'C1'
df.comp
# Clear Namespace
rm(list=ls())
# Import Libraries
library(ggplot2)
set.seed(7)
p.x = runif(100, min = 0, max = 10)
p.y = runif(100, min = 0, max = 10)
plot(p.x, p.y)
# Create DataFrame with X & Y Values
df.pxy = data.frame(p.x, p.y)
# Randomly Generate K Centroids
K.1 = 2
c.x = runif(K.1, min = 0, max = 10)
c.y = runif(K.1, min = 0, max = 10)
# Centroid 1
c1.x = c.x[1]
c1.y = c.y[1]
df.c1 = data.frame(c1.x, c1.y)
# Centroid 2
c2.x = c.x[2]
c2.y = c.y[2]
df.c2 = data.frame(c2.x, c2.y)
# Plot Random Data + Centroids
p <- ggplot(df.pxy, aes(x = p.x, y = p.y)) + geom_point()
p + geom_point(data = df.c1, aes(x = c1.x, y = c2.y), colour = 'red', size =5) +
geom_point(data = df.c2, aes(x = c2.x, y = c2.y), colour = 'blue', size =5)
# Calculate Euclidean Distance to Each Centroid
e.distance <- function(p.x, p.y, c.x, c.y){
'p.x/p.y:  Randomly generated x/y points
c.x/c.y:  Centroid x & y coordinates'
a = (p.x - c.x)^2
b = (p.y - c.y)^2
c = sqrt(a + b)
return(c)
}
e.dist.c1 = e.distance(p.x, p.y, c1.x, c1.y)
e.dist.c2 = e.distance(p.x, p.y, c2.x, c2.y)
# Create DataFrame w/ x/y points, distance to c1, c2
comp.dist = e.dist.c1 > e.dist.c2
df.comp = data.frame(p.x, p.y, e.dist.c1, e.dist.c2, comp.dist)
df.comp
df.comp$comp.dist[df.comp$comp.dist == TRUE] <- 'C2'
df.comp$comp.dist[df.comp$comp.dist == FALSE] <- 'C1'
df.comp
p <- ggplot(df.comp[df.comp$comp.dist == 'C1'], aes(x = p.x, y = p.y)) + geom_point()
p <- ggplot(df.comp[df.comp$comp.dist == 'C1'], aes(x = p.x, y = p.y)) + geom_point()
# Clear Namespace
rm(list=ls())
# Import Libraries
library(ggplot2)
rm(list=ls())
# Import Libraries
library(ggplot2)
# Step 1:  Generate two random datasets (R2)
set.seed(7)
p.x = runif(100, min = 0, max = 10)
p.y = runif(100, min = 0, max = 10)
plot(p.x, p.y)
# Create DataFrame with X & Y Values
df.pxy = data.frame(p.x, p.y)
plot(df.pxy)
# Centroid 1
c1.x = runif(1, min = 5, max = 10)
c1.y = runif(1, min = 5, max = 10)
df.c1 = data.frame(c1.x, c1.y)
df.c1
# Centroid 2
c2.x = runif(1, min = 0, max = 5)
c2.y = runif(1, min = 0, max = 5)
df.c2 = data.frame(c2.x, c2.y)
df.c2
rm(list=ls())
# Import Libraries
library(ggplot2)
# Step 1:  Generate A Random Dataset
set.seed(7)
p.x = runif(100, min = 0, max = 10)
p.y = runif(100, min = 0, max = 10)
plot(p.x, p.y)
# Create DataFrame with X & Y Values
df.pxy = data.frame(p.x, p.y)
plot(df.pxy)
head(df.pxy)
# Limit Data - Values
sf_data_lim.1 %<>% filter(Stage == 'Bound')
%<>%
?%<>%
library(dplyr)
# Limit Data - Values
sf_data_lim.1 %<>% filter(Stage == 'Bound')
library(magrittr)
# Limit Data - Values
sf_data_lim.1 %<>% filter(Stage == 'Bound')
# Clear Namespace
rm(list=ls())
# Clear Namespace
rm(list=ls())
# Load Libraries
library(tidyverse)
library(dplyr)
library(magrittr)
# Set Working Directory
getwd()
setwd('C:\\Users\\Chris.Cirelli\\Desktop\\Programming_Repositories\\Clustering_Algorithms\\Data')
# Load CSV FIle
list.files()
sf_data <- read.csv('sf_data_06052019.csv')
head(sf_data)
sf_data_lim.1 <- select(sf_data, Annual.Revenue, Employees, Submission.Type, Stage)
# Limit Data - Values
sf_data_lim.1 %<>% filter(Stage == 'Bound')
head(sf_data_lim.1)
rm(list=ls())
# Load Libraries
library(tidyverse)
library(dplyr)
library(magrittr)
# Set Working Directory
getwd()
setwd('C:\\Users\\Chris.Cirelli\\Desktop\\Programming_Repositories\\Clustering_Algorithms\\Data')
# Load CSV FIle
list.files()
sf_data <- read.csv('sf_data_06052019.csv')
head(sf_data)
# Limit Data - Columns
' Columns      Limit to Employee Count, Revenues, Type, Stage'
sf_data_lim.1 <- select(sf_data, Annual.Revenue, Employees, Submission.Type, Stage)
# Limit Data - Values
sf_data_lim.1 %<>% filter(Stage == 'Bound' | 'Declined')
# Limit Data - Values
sf_data_lim.1 %<>% filter(Stage == 'Bound' | == 'Declined')
# Limit Data - Values
sf_data_lim.1 %<>% filter(Stage == 'Bound' | 'Declined')
sf_data_lim.1$Stage
# Limit Data - Values
sf_data_lim.1 %<>% filter(Stage == 'Bound' && == 'Declined')
# Limit Data - Values
sf_data_lim.1 %<>% filter(Stage == 'Bound' & == 'Declined')
# Limit Data - Values
sf_data_lim.1 %<>% filter(Stage == 'Bound' && 'Declined')
head(sf_data_lim.1)
# Limit Data - Values
sf_data_lim.1 %<>% filter(Stage == 'Bound' & 'Declined')
head(sf_data_lim.1)
# Limit Data - Values
sf_data_lim.1 %<>% filter(Stage == 'Bound', Stage == 'Declined')
head(sf_data_lim.1)
# Clear Namespace
rm(list=ls())
# Load Libraries
library(tidyverse)
library(dplyr)
library(magrittr)
# Set Working Directory
getwd()
setwd('C:\\Users\\Chris.Cirelli\\Desktop\\Programming_Repositories\\Clustering_Algorithms\\Data')
# Load CSV FIle
list.files()
sf_data <- read.csv('sf_data_06052019.csv')
head(sf_data)
# Limit Data - Columns
' Columns      Limit to Employee Count, Revenues, Type, Stage'
sf_data_lim.1 <- select(sf_data, Annual.Revenue, Employees, Submission.Type, Stage)
sf_data_lim.1$Stage
# Limit Data - Values
sf_data_lim.1 %<>% filter(Stage == 'Bound', Stage == 'Declined')
head(sf_data_lim.1)
# Limit Data - Values
sf_data_lim.1 %<>% filter(Stage == 'Bound')
head(sf_data_lim.1)
sf_data_lim.1 <- select(sf_data, Annual.Revenue, Employees, Submission.Type, Stage)
sf_data_lim.1$Stage
# Limit Data - Values
sf_data_lim.1 %<>% filter(Stage == 'Bound')
head(sf_data_lim.1)
# Load CSV FIle
list.files()
sf_data <- read.csv('sf_data_06052019.csv')
head(sf_data)
sf_data_lim.1 <- select(sf_data, Annual.Revenue, Employees, Submission.Type, Stage)
head(sf_data_lim.1)
# Limit Data - Values
sf_data_bound <- %>% filter(Stage == 'Bound')
# Limit Data - Values
sf_data_bound %>% filter(Stage == 'Bound')
# Limit Data - Values
sf_data_bound <- sf_data_lim.1 %>% filter(Stage == 'Bound')
head(sf_data_bound)
sf_data_bound <- sf_data_lim.1 %>% filter(Stage == 'Bound', Annual.Revenue !+ 0,
Employees != 0)
sf_data_bound <- sf_data_lim.1 %>% filter(Stage == 'Bound', Annual.Revenue != 0,
Employees != 0)
head(sf_data_bound)
sf_data_declined <- sf_data_lim.1 %>% filter(Stage == 'Declined', Annual.Revenue != 0,
Employees != 0)
sf_data_declined
sf_data_declined <- sf_data_lim.1 %>% filter(Stage == 'Declined', Annual.Revenue != 0,
Employees != 0) %>% select(sf_data_declined, Annual.Revenue, Employees)
sf_data_declined <- sf_data_lim.1 %>% filter(Stage == 'Declined', Annual.Revenue != 0,
Employees != 0)
sf_data_declined <- select(sf_data_lim.1 %>% filter(Stage == 'Declined', Annual.Revenue != 0,
Employees != 0), Annual.Revenue, Employees)
head(sf_data_declined)
rm(list=ls())
# Load Libraries
library(tidyverse)
library(dplyr)
library(magrittr)
# Set Working Directory
getwd()
setwd('C:\\Users\\Chris.Cirelli\\Desktop\\Programming_Repositories\\Clustering_Algorithms\\Data')
# Load CSV FIle
list.files()
sf_data <- read.csv('sf_data_06052019.csv')
# Limit Data - Columns
' Columns      Limit to Employee Count, Revenues, Type, Stage'
sf_data_lim.1 <- select(sf_data, Annual.Revenue, Employees, Submission.Type, Stage)
head(sf_data_lim.1)
head(sf_data)
sf_data_lim.1 <- select(sf_data, Annual.Revenue, Employees, Submission.Type, Stage, Line.of.Business)
head(sf_data_lim.1)
sf_data_lim.1 <- select(sf_data %>% filter(Line.of.Business == 'Private/NFP'),
Annual.Revenue, Employees, Submission.Type, Stage, Line.of.Business)
head(sf_data_lim.1)
sf_data_bound <-    select(sf_data_lim.1 %>% filter(Stage == 'Bound', Annual.Revenue != 0, Employees != 0),
Annual.Revenue, Employees)
sf_data_declined <- select(sf_data_lim.1 %>% filter(Stage == 'Declined', Annual.Revenue != 0, Employees != 0),
Annual.Revenue, Employees)
head(sf_data_bound)
head(sf_data_declined)
plot(sf_data_bound$Annual.Revenue)
boxplot(sf_data_bound$Annual.Revenue)
boxplot(sf_data_declined$Annual.Revenue)
density(sf_data_declined$Annual.Revenue)
plot(density(sf_data_declined$Annual.Revenue))
k.means(num.data.points = 300,
num.centroids   = 4,
num.iters       = 6)
rm(list=ls())
# IMPORT LIBRARIES
library(ggplot2)
library(dplyr)
setwd('C:\\Users\\Chris.Cirelli\\Desktop\\Programming_Repositories\\Clustering_Algorithms')
source('module1_kmeans_algorithm.R')
# DRIVER FUNCTION - K MEANS CLUSTER--------------------------------------------------
k.means <- function(num.data.points, num.centroids, num.iters){
# Step 1:  Generate Random Dataset
set.seed(7)
p.x = runif(num.data.points, min = 0, max = 10)
p.y = runif(num.data.points, min = 0, max = 10)
# Step 2:  Create DataFrame with X & Y Values
df.d = data.frame(p.x, p.y)
# Step 3:  Generate Random Data Points For K Centroids
df.c <- f.centroids(num.centroids)
# Step4:   Iterate N times each time recalculating the centroids
for (i in seq(1, num.iters)){
# a.  Print User Log
print(paste('Starting Iteration =>', i))
# b.  Calculate Euclidean Distance 2 Each Centroid
df.d.c.dist <- get.euclid.dist(df.d, df.c)
# c.  Create Assignments Based on Distance to Nearest Centroid
df.c.assignments <- c.assignments(df.d.c.dist)
# d.  Plot The Assignment of Each Point & Centroid
plot.c.assignments(df.c.assignments, df.c, i)
# e.  Calculate the within and between cluster mse
sys.mse <- round(calc.mse(df.c.assignments),2)
print(paste('MSE => ', sys.mse))
# f.  Set Delay between iterations
Sys.sleep(2)
# g.  Recalculate Centroids
df.c <- re.calc.centroids(df.c.assignments)
}
}
k.means(num.data.points = 300,
num.centroids   = 4,
num.iters       = 6)
# CLEAR NAME SPACE
rm(list=ls())
# IMPORT LIBRARIES
library(ggplot2)
library(dplyr)
setwd('C:\\Users\\Chris.Cirelli\\Desktop\\Programming_Repositories\\Clustering_Algorithms')
source('module1_kmeans_algorithm.R')
setwd('C:\\Users\\Chris.Cirelli\\Desktop\\Programming_Repositories\\Clustering_Algorithms\\Code')
source('module1_kmeans_algorithm.R')
# DRIVER FUNCTION - K MEANS CLUSTER--------------------------------------------------
k.means <- function(num.data.points, num.centroids, num.iters){
# Step 1:  Generate Random Dataset
set.seed(7)
p.x = runif(num.data.points, min = 0, max = 10)
p.y = runif(num.data.points, min = 0, max = 10)
# Step 2:  Create DataFrame with X & Y Values
df.d = data.frame(p.x, p.y)
# Step 3:  Generate Random Data Points For K Centroids
df.c <- f.centroids(num.centroids)
# Step4:   Iterate N times each time recalculating the centroids
for (i in seq(1, num.iters)){
# a.  Print User Log
print(paste('Starting Iteration =>', i))
# b.  Calculate Euclidean Distance 2 Each Centroid
df.d.c.dist <- get.euclid.dist(df.d, df.c)
# c.  Create Assignments Based on Distance to Nearest Centroid
df.c.assignments <- c.assignments(df.d.c.dist)
# d.  Plot The Assignment of Each Point & Centroid
plot.c.assignments(df.c.assignments, df.c, i)
# e.  Calculate the within and between cluster mse
sys.mse <- round(calc.mse(df.c.assignments),2)
print(paste('MSE => ', sys.mse))
# f.  Set Delay between iterations
Sys.sleep(2)
# g.  Recalculate Centroids
df.c <- re.calc.centroids(df.c.assignments)
}
}
k.means(num.data.points = 300,
num.centroids   = 4,
num.iters       = 6)
k.means(num.data.points = 300,
num.centroids   = 4,
num.iters       = 6)
p.1 <- ggplot(df.d, aes(x=p.x, y=p.y)) + geom_point()
# Step 2:  Create DataFrame with X & Y Values
df.d = data.frame(p.x, p.y)
k.means <- function(num.data.points, num.centroids, num.iters){
# Step 1:  Generate Random Dataset
set.seed(7)
p.x = runif(num.data.points, min = 0, max = 10)
p.y = runif(num.data.points, min = 0, max = 10)
# Step 2:  Create DataFrame with X & Y Values
df.d = data.frame(p.x, p.y)
p.1 <- ggplot(df.d, aes(x=p.x, y=p.y)) + geom_point() + ggtitle('RAW DATA')
# Step 3:  Generate Random Data Points For K Centroids
df.c <- f.centroids(num.centroids)
# Step4:   Iterate N times each time recalculating the centroids
for (i in seq(1, num.iters)){
# a.  Print User Log
print(paste('Starting Iteration =>', i))
# b.  Calculate Euclidean Distance 2 Each Centroid
df.d.c.dist <- get.euclid.dist(df.d, df.c)
# c.  Create Assignments Based on Distance to Nearest Centroid
df.c.assignments <- c.assignments(df.d.c.dist)
# d.  Plot The Assignment of Each Point & Centroid
plot.c.assignments(df.c.assignments, df.c, i)
# e.  Calculate the within and between cluster mse
sys.mse <- round(calc.mse(df.c.assignments),2)
print(paste('MSE => ', sys.mse))
# f.  Set Delay between iterations
Sys.sleep(2)
# g.  Recalculate Centroids
df.c <- re.calc.centroids(df.c.assignments)
}
}
k.means(num.data.points = 300,
num.centroids   = 4,
num.iters       = 6)
k.means <- function(num.data.points, num.centroids, num.iters){
# Step 1:  Generate Random Dataset
set.seed(7)
p.x = runif(num.data.points, min = 0, max = 10)
p.y = runif(num.data.points, min = 0, max = 10)
# Step 2:  Create DataFrame with X & Y Values
df.d = data.frame(p.x, p.y)
p.1 <- ggplot(df.d, aes(x=p.x, y=p.y)) + geom_point() + ggtitle('RAW DATA')
p.1
# Step 3:  Generate Random Data Points For K Centroids
df.c <- f.centroids(num.centroids)
# Step4:   Iterate N times each time recalculating the centroids
for (i in seq(1, num.iters)){
# a.  Print User Log
print(paste('Starting Iteration =>', i))
# b.  Calculate Euclidean Distance 2 Each Centroid
df.d.c.dist <- get.euclid.dist(df.d, df.c)
# c.  Create Assignments Based on Distance to Nearest Centroid
df.c.assignments <- c.assignments(df.d.c.dist)
# d.  Plot The Assignment of Each Point & Centroid
plot.c.assignments(df.c.assignments, df.c, i)
# e.  Calculate the within and between cluster mse
sys.mse <- round(calc.mse(df.c.assignments),2)
print(paste('MSE => ', sys.mse))
# f.  Set Delay between iterations
Sys.sleep(2)
# g.  Recalculate Centroids
df.c <- re.calc.centroids(df.c.assignments)
}
}
k.means(num.data.points = 300,
num.centroids   = 4,
num.iters       = 6)
# DRIVER FUNCTION - K MEANS CLUSTER--------------------------------------------------
k.means <- function(num.data.points, num.centroids, num.iters){
# Step 1:  Generate Random Dataset
set.seed(7)
p.x = runif(num.data.points, min = 0, max = 10)
p.y = runif(num.data.points, min = 0, max = 10)
# Step 2:  Create DataFrame with X & Y Values
df.d = data.frame(p.x, p.y)
p.1 <- ggplot(df.d, aes(x=p.x, y=p.y)) + geom_point() + ggtitle('RAW DATA')
print(p.1)
Sys.sleep(2)
# Step 3:  Generate Random Data Points For K Centroids
df.c <- f.centroids(num.centroids)
# Step4:   Iterate N times each time recalculating the centroids
for (i in seq(1, num.iters)){
# a.  Print User Log
print(paste('Starting Iteration =>', i))
# b.  Calculate Euclidean Distance 2 Each Centroid
df.d.c.dist <- get.euclid.dist(df.d, df.c)
# c.  Create Assignments Based on Distance to Nearest Centroid
df.c.assignments <- c.assignments(df.d.c.dist)
# d.  Plot The Assignment of Each Point & Centroid
plot.c.assignments(df.c.assignments, df.c, i)
# e.  Calculate the within and between cluster mse
sys.mse <- round(calc.mse(df.c.assignments),2)
print(paste('MSE => ', sys.mse))
# f.  Set Delay between iterations
Sys.sleep(2)
# g.  Recalculate Centroids
df.c <- re.calc.centroids(df.c.assignments)
}
}
k.means(num.data.points = 300,
num.centroids   = 4,
num.iters       = 6)
library(ggplot2)
library(dplyr)
setwd('C:\\Users\\Chris.Cirelli\\Desktop\\Programming_Repositories\\Clustering_Algorithms\\Code')
source('module1_kmeans_algorithm.R')
k.means <- function(num.data.points, num.centroids, num.iters){
# Step 1:  Generate Random Dataset
set.seed(7)
p.x = runif(num.data.points, min = 0, max = 10)
p.y = runif(num.data.points, min = 0, max = 10)
# Step 2:  Create DataFrame with X & Y Values
df.d = data.frame(p.x, p.y)
p.1 <- ggplot(df.d, aes(x=p.x, y=p.y)) + geom_point() + ggtitle('RAW DATA')
print(p.1)
Sys.sleep(4)
# Step 3:  Generate Random Data Points For K Centroids
df.c <- f.centroids(num.centroids)
# Step4:   Iterate N times each time recalculating the centroids
for (i in seq(1, num.iters)){
# a.  Print User Log
print(paste('Starting Iteration =>', i))
# b.  Calculate Euclidean Distance 2 Each Centroid
df.d.c.dist <- get.euclid.dist(df.d, df.c)
# c.  Create Assignments Based on Distance to Nearest Centroid
df.c.assignments <- c.assignments(df.d.c.dist)
# d.  Plot The Assignment of Each Point & Centroid
plot.c.assignments(df.c.assignments, df.c, i)
# e.  Calculate the within and between cluster mse
sys.mse <- round(calc.mse(df.c.assignments),2)
print(paste('MSE => ', sys.mse))
# f.  Set Delay between iterations
Sys.sleep(2)
# g.  Recalculate Centroids
df.c <- re.calc.centroids(df.c.assignments)
}
}
k.means(num.data.points = 300,
num.centroids   = 4,
num.iters       = 6)
k.means(num.data.points = 300,
num.centroids   = 4,
num.iters       = 6)
# IMPORT LIBRARIES
library(ggplot2)
library(dplyr)
setwd('C:\\Users\\Chris.Cirelli\\Desktop\\Programming_Repositories\\Clustering_Algorithms\\Code')
source('module1_kmeans_algorithm.R')
# DRIVER FUNCTION - K MEANS CLUSTER--------------------------------------------------
k.means <- function(num.data.points, num.centroids, num.iters){
# Step 1:  Generate Random Dataset
set.seed(7)
p.x = runif(num.data.points, min = 0, max = 10)
p.y = runif(num.data.points, min = 0, max = 10)
# Step 2:  Create DataFrame with X & Y Values
df.d = data.frame(p.x, p.y)
p.1 <- ggplot(df.d, aes(x=p.x, y=p.y)) + geom_point() + ggtitle('RAW DATA')
print(p.1)
Sys.sleep(4)
# Step 3:  Generate Random Data Points For K Centroids
df.c <- f.centroids(num.centroids)
# Step4:   Iterate N times each time recalculating the centroids
for (i in seq(1, num.iters)){
# a.  Print User Log
print(paste('Starting Iteration =>', i))
# b.  Calculate Euclidean Distance 2 Each Centroid
df.d.c.dist <- get.euclid.dist(df.d, df.c)
# c.  Create Assignments Based on Distance to Nearest Centroid
df.c.assignments <- c.assignments(df.d.c.dist)
# d.  Plot The Assignment of Each Point & Centroid
plot.c.assignments(df.c.assignments, df.c, i)
# e.  Calculate the within and between cluster mse
sys.mse <- round(calc.mse(df.c.assignments),2)
print(paste('MSE => ', sys.mse))
# f.  Set Delay between iterations
Sys.sleep(4)
# g.  Recalculate Centroids
df.c <- re.calc.centroids(df.c.assignments)
}
}
k.means(num.data.points = 300,
num.centroids   = 4,
num.iters       = 6)
k.means(num.data.points = 300,
num.centroids   = 4,
num.iters       = 6)
k.means(num.data.points = 300,
num.centroids   = 2,
num.iters       = 6)
