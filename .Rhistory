# For Loop (Iters = num centroids)
for (i in seq(1,length(df.c[,1]))){
# Count Object - Convert to character
c.count <- as.character(i)
# Create Col Name For Each Centroid
c.n <- paste('c.', c.count, sep='')
# Calculate the Distance From Each Data Point to Each Centroid
'df.c$x[i]:  Each row in our dataframe represents a diff centroid.  So we use the count of the for loop
to iterate each row.  c^2 = a^2 + b^2'
df.d$c.n <- sqrt((df.d$p.x - df.c$x[i])^2 + (df.d$p.y - df.c$y[i])^2)
# Rename Col w/ Centroid Number (i+2 because we start w/ two cols x & y)
colnames(df.d)[i+2] <- c.n
}
# Return Data frame
return(df.data)
}
# Calculate Euclidean Distance 2 Each Centroid
test.1 <- get.euclid.dist(df.pxy, c.1)
get.euclid.dist(df.pxy, c.1)
get.euclid.dist <- function(df.d, df.c){
'Inputs:      df.c = data frame containing centroids.
df.d = data frame containing randomly generated data points.
Output:      dataframe that includes data points & dist to centroids'
# For Loop (Iters = num centroids)
for (i in seq(1,length(df.c[,1]))){
# Count Object - Convert to character
c.count <- as.character(i)
print(c.count)
# Create Col Name For Each Centroid
c.n <- paste('c.', c.count, sep='')
# Calculate the Distance From Each Data Point to Each Centroid
'df.c$x[i]:  Each row in our dataframe represents a diff centroid.  So we use the count of the for loop
to iterate each row.  c^2 = a^2 + b^2'
df.d$c.n <- sqrt((df.d$p.x - df.c$x[i])^2 + (df.d$p.y - df.c$y[i])^2)
# Rename Col w/ Centroid Number (i+2 because we start w/ two cols x & y)
colnames(df.d)[i+2] <- c.n
}
# Return Data frame
return(df.data)
}
get.euclid.dist(df.pxy, c.1)
get.euclid.dist <- function(df.d, df.c){
'Inputs:      df.c = data frame containing centroids.
df.d = data frame containing randomly generated data points.
Output:      dataframe that includes data points & dist to centroids'
# For Loop (Iters = num centroids)
for (i in seq(1,length(df.c[,1]))){
# Count Object - Convert to character
c.count <- as.character(i)
print(c.count)
# Create Col Name For Each Centroid
c.n <- paste('c.', c.count, sep='')
# Calculate the Distance From Each Data Point to Each Centroid
'df.c$x[i]:  Each row in our dataframe represents a diff centroid.  So we use the count of the for loop
to iterate each row.  c^2 = a^2 + b^2'
df.d$c.n <- sqrt((df.d$p.x - df.c$x[i])^2 + (df.d$p.y - df.c$y[i])^2)
# Rename Col w/ Centroid Number (i+2 because we start w/ two cols x & y)
colnames(df.d)[i+2] <- c.n
}
# Return Data frame
return(df.d)
}
get.euclid.dist(df.pxy, c.1)
# Clear Namespace
rm(list=ls())
# Import Libraries
library(ggplot2)
setwd('C:\\Users\\Chris.Cirelli\\Desktop\\Programming_Repositories\\Clustering_Algorithms')
source('module1_kmeans_algorithm.R')
# Step 1:  Generate A Random Dataset
set.seed(7)
p.x = runif(100, min = 0, max = 10)
p.y = runif(100, min = 0, max = 10)
plot(p.x, p.y)
# Create DataFrame with X & Y Values
df.pxy = data.frame(p.x, p.y)
plot(df.pxy)
head(df.pxy)
# Generate Data Points For K Centroids
c.1 <- f.centroids(4)
get.euclid.dist <- function(df.d, df.c){
'Inputs:      df.c = data frame containing centroids.
df.d = data frame containing randomly generated data points.
Output:      dataframe that includes data points & dist to centroids'
# For Loop (Iters = num centroids)
for (i in seq(1,length(df.c[,1]))){
# Count Object - Convert to character
c.count <- as.character(i)
print(c.count)
# Create Col Name For Each Centroid
c.n <- paste('c.', c.count, sep='')
# Calculate the Distance From Each Data Point to Each Centroid
'df.c$x[i]:  Each row in our dataframe represents a diff centroid.  So we use the count of the for loop
to iterate each row.  c^2 = a^2 + b^2'
df.d$c.n <- sqrt((df.d$p.x - df.c$x[i])^2 + (df.d$p.y - df.c$y[i])^2)
# Rename Col w/ Centroid Number (i+2 because we start w/ two cols x & y)
colnames(df.d)[i+2] <- c.n
}
# Return Data frame
return(df.d)
}
head(get.euclid.dist(df.pxy, c.1))
plot(c.1)
get.euclid.dist <- function(df.d, df.c){
'Inputs:      df.c = data frame containing centroids.
df.d = data frame containing randomly generated data points.
Output:      dataframe that includes data points & dist to centroids'
# For Loop (Iters = num centroids)
for (i in seq(1,length(df.c[,1]))){
# Count Object - Convert to character
c.count <- as.character(i)
print(c.count)
# Create Col Name For Each Centroid
c.n <- paste('c.', c.count, sep='')
# Calculate the Distance From Each Data Point to Each Centroid
'df.c$x[i]:  Each row in our dataframe represents a diff centroid.  So we use the count of the for loop
to iterate each row.  c^2 = a^2 + b^2'
df.d$c.n <- sqrt((df.d$p.x - df.c$x[i])^2 + (df.d$p.y - df.c$y[i])^2)
# Rename Col w/ Centroid Number (i+2 because we start w/ two cols x & y)
colnames(df.d)[i+2] <- c.n
}
# Return Data frame
return(df.d)
}
# Clear Namespace
rm(list=ls())
# Import Libraries
library(ggplot2)
setwd('C:\\Users\\Chris.Cirelli\\Desktop\\Programming_Repositories\\Clustering_Algorithms')
source('module1_kmeans_algorithm.R')
# Step 1:  Generate A Random Dataset
set.seed(7)
p.x = runif(100, min = 0, max = 10)
p.y = runif(100, min = 0, max = 10)
plot(p.x, p.y)
# Create DataFrame with X & Y Values
df.pxy = data.frame(p.x, p.y)
plot(df.pxy)
head(df.pxy)
# Generate Data Points For K Centroids
c.1 <- f.centroids(4)
# Calculate Euclidean Distance 2 Each Centroid
head(get.euclid.dist(df.pxy, c.1))
# Calculate Euclidean Distance 2 Each Centroid
df.pxy.c.dist <- get.euclid.dist(df.pxy, c.1)
# Calculate Euclidean Distance 2 Each Centroid
df.pxy.c.dist <- get.euclid.dist(df.pxy, c.1)
# Clear Namespace
rm(list=ls())
# Import Libraries
library(ggplot2)
setwd('C:\\Users\\Chris.Cirelli\\Desktop\\Programming_Repositories\\Clustering_Algorithms')
source('module1_kmeans_algorithm.R')
# Step 1:  Generate A Random Dataset
set.seed(7)
p.x = runif(100, min = 0, max = 10)
p.y = runif(100, min = 0, max = 10)
# Create DataFrame with X & Y Values
df.d = data.frame(p.x, p.y)
# Generate Data Points For K Centroids
df.c <- f.centroids(4)
p.1 <- ggplot(df.d, aes(x = p.x, y = p.y)) + geom_point() +
geom_point(data=df.c, colour='red', size=5)
p.1
p.1 <- ggplot(df.d, aes(x = p.x, y = p.y)) + geom_point() +
geom_point(data=df.c, aes(x=df.c$x, y=df.c$y) colour='red', size=5)
# Initial Scatter Plot w/ Centroids
p.1 <- ggplot(df.d, aes(x = p.x, y = p.y)) + geom_point() +
geom_point(data=df.c, aes(x=df.c$x, y=df.c$y), colour='red', size=5)
p.1
p.1 <- ggplot(df.d, aes(x = p.x, y = p.y)) + geom_point() +
geom_point(data=df.c, aes(x=df.c$x, y=df.c$y), colour='red', size=5) +
geom_tile('Initial Plot - Data Cloud + Centroids')
p.1
p.1 <- ggplot(df.d, aes(x = p.x, y = p.y)) + geom_point() +
geom_point(data=df.c, aes(x=df.c$x, y=df.c$y), colour='red', size=5) +
geom_title('Initial Plot - Data Cloud + Centroids')
p.1
p.1 <- ggplot(df.d, aes(x = p.x, y = p.y)) + geom_point() +
geom_point(data=df.c, aes(x=df.c$x, y=df.c$y), colour='red', size=5) +
title('Initial Plot - Data Cloud + Centroids')
p.1
p.1 <- ggplot(df.d, aes(x = p.x, y = p.y)) + geom_point() +
geom_point(data=df.c, aes(x=df.c$x, y=df.c$y), colour='red', size=5) +
ggtitle('Initial Plot - Data Cloud + Centroids')
p.1
head(df.d.c.dist)
# Calculate Euclidean Distance 2 Each Centroid
df.d.c.dist <- get.euclid.dist(df.pxy, c.1)
# Calculate Euclidean Distance 2 Each Centroid
df.d.c.dist <- get.euclid.dist(df.pxy, df.c)
# Calculate Euclidean Distance 2 Each Centroid
df.d.c.dist <- get.euclid.dist(df.d, df.c)
head(df.d.c.dist)
length(df.c[1])
df.c[1]
length(df.c[1])
length(df.c[,1])
df.c[,1]
df.d.c.dist[1,]
df.d.c.dist[2,]
df.d.c.dist[1,2:]
df.d.c.dist[1,2:4]
df.d.c.dist[1, 2: length(df.c[,1])]
head(df.d.c.dist)
df.d.c.dist[1, 3: length(df.c[,1])]
df.d.c.dist[1, 3: length(df.d.c.dist[,1])]
df.d.c.dist[1, 3: length(df.d.c.dist[1])]
#df.d.c.dist[1, 3:
length(df.d.c.dist[1])
#df.d.c.dist[1, 3:
length(df.d.c.dist[,1])
#df.d.c.dist[1, 3:
length(df.d.c.dist[1,])
#df.d.c.dist[1, 3:
num.cols <- length(df.d.c.dist[1,])
df.d.c.dist[1, 3: num.cols]
e.dist.vector <- df.d.c.dist[1, 3: num.cols]
e.dist.vector[1]
e.dist.vector[1] > e.dist.vector
2 > e.dist.vector
min(e.dist.vector)
min.e.dist <- min(e.dist.vector)
min.e.dist
min.e.dist = e.dist.vector
head(df.d.c.dist)
num.cols <- length(df.d.c.dist[1,])
e.dist.vector <- df.d.c.dist[1, 3: num.cols]
min.e.dist <- min(e.dist.vector)
min.e.dist == e.dist.vector
min.value <- min.e.dist == e.dist.vector
min.value
min.value[TRUE]
min.value[min.value ==TRUE]
col.name(min.value[min.value ==TRUE])
colnames(min.value[min.value ==TRUE])
min.value[min.value ==TRUE,]
min.valu
min.value
colnames(min.value)
colnames(min.value[min.value ==TRUE])
min.value
class(min.value)
data.frame(min.value)
class(test)
test = data.frame(min.value)
class(test)
colnames(test)
colnames(test[test == TRUE])
test[test == TRUE]
colnames(test)
for (i in test){
if (i == TRUE){
print('True Found')
}
}
for (i in test){
count = count+1
if (i == TRUE){
print(paste('col num =', count))
}
}
count = 0
for (i in test){
count = count+1
if (i == TRUE){
print(paste('col num =', count))
}
}
head(df.d.c.dist)
head(df.d.c.dist)
num.cols <- length(df.d.c.dist[1,])
e.dist.vector <- df.d.c.dist[1, 3: num.cols]
e.dist.vector
class(min.value)
class(as.data.frame(min.value))
get.col.name <- function(min.value.matrix){
'Input:    min.value is a matrix.  Convert to df
Output:   col name w/ min e.dist value'
df.min.value <- data.frame(min.value)
count = 0
col.num = ''
for (i in df.min.value){
count = count+1
# Identify Col == True
if (i == TRUE){
# Assign i value to col.num
col.num = i
}
}
return(paste('c.', col.num))
}
head(df.d.c.dist)
test.1 <- head(df.d.c.dist)
c.assignments(test.1)
c.assignments <- function(df.d){
'Input:     data frame that includes data + dist to centroids
Output:    same data frame w/ a new col with centroid assignments'
# Get Number of Cols (necessary as we need to tell the program how many centroids were gen)
num.cols <- length(df.d[1,])
# Isolate col/vector w/ distance measure to each centroid
e.dist.vector <- df.d[1, 3: num.cols]
# Get the Min Distance (essentially the min value of this vector)
min.e.dist <- min(e.dist.vector)
# Generate Bolean Values based on which col == min value
min.value <- min.e.dist == e.dist.vector
# Iterate vector to identify which centroid has the min dist
col.name.min.value <- get.col.name(min.value)
print(paste('Column w/ min dist value =', col.name.min.value))
# Return Value
}
test.1 <- head(df.d.c.dist)
c.assignments(test.1)
get.col.name <- function(min.value.matrix){
'Input:    min.value is a matrix.  Convert to df
Output:   col name w/ min e.dist value'
df.min.value <- data.frame(min.value)
count = 0
col.num = ''
for (i in df.min.value){
print(i)
count = count+1
# Identify Col == True
if (i == TRUE){
# Assign i value to col.num
col.num = i
}
}
get.col.name <- function(min.value.matrix){
'Input:    min.value is a matrix.  Convert to df
Output:   col name w/ min e.dist value'
df.min.value <- data.frame(min.value)
count = 0
col.num = ''
for (i in df.min.value){
print(i)
count = count+1
# Identify Col == True
if (i == TRUE){
# Assign i value to col.num
col.num = i
}
}
return(paste('c.', col.num))
}
c.assignments <- function(df.d){
'Input:     data frame that includes data + dist to centroids
Output:    same data frame w/ a new col with centroid assignments'
# Get Number of Cols (necessary as we need to tell the program how many centroids were gen)
num.cols <- length(df.d[1,])
# Isolate col/vector w/ distance measure to each centroid
e.dist.vector <- df.d[1, 3: num.cols]
# Get the Min Distance (essentially the min value of this vector)
min.e.dist <- min(e.dist.vector)
# Generate Bolean Values based on which col == min value
min.value <- min.e.dist == e.dist.vector
# Iterate vector to identify which centroid has the min dist
col.name.min.value <- get.col.name(min.value)
print(paste('Column w/ min dist value =', col.name.min.value))
# Return Value
}
test.1 <- head(df.d.c.dist)
c.assignments(test.1)
# Clear Namespace
rm(list=ls())
# Import Libraries
library(ggplot2)
setwd('C:\\Users\\Chris.Cirelli\\Desktop\\Programming_Repositories\\Clustering_Algorithms')
source('module1_kmeans_algorithm.R')
# Step 1:  Generate A Random Dataset
set.seed(7)
p.x = runif(100, min = 0, max = 10)
p.y = runif(100, min = 0, max = 10)
# Create DataFrame with X & Y Values
df.d = data.frame(p.x, p.y)
# Generate Data Points For K Centroids
df.c <- f.centroids(4)
# Initial Scatter Plot w/ Centroids
p.1 <- ggplot(df.d, aes(x = p.x, y = p.y)) + geom_point() +
geom_point(data=df.c, aes(x=df.c$x, y=df.c$y), colour='red', size=5) +
ggtitle('Initial Plot - Data Cloud + Centroids')
p.1
# Calculate Euclidean Distance 2 Each Centroid
df.d.c.dist <- get.euclid.dist(df.d, df.c)
get.col.name <- function(min.value.matrix){
'Input:    min.value is a matrix.  Convert to df
Output:   col name w/ min e.dist value'
df.min.value <- data.frame(min.value)
count = 0
col.num = ''
for (i in df.min.value){
print(i)
count = count+1
# Identify Col == True
if (i == TRUE){
# Assign i value to col.num
col.num = i
}
}
return(paste('c.', col.num))
}
c.assignments <- function(df.d){
'Input:     data frame that includes data + dist to centroids
Output:    same data frame w/ a new col with centroid assignments'
# Get Number of Cols (necessary as we need to tell the program how many centroids were gen)
num.cols <- length(df.d[1,])
# Isolate col/vector w/ distance measure to each centroid
e.dist.vector <- df.d[1, 3: num.cols]
# Get the Min Distance (essentially the min value of this vector)
min.e.dist <- min(e.dist.vector)
# Generate Bolean Values based on which col == min value
min.value <- min.e.dist == e.dist.vector
# Iterate vector to identify which centroid has the min dist
col.name.min.value <- get.col.name(min.value)
print(paste('Column w/ min dist value =', col.name.min.value))
# Return Value
}
test.1 <- head(df.d.c.dist)
c.assignments(test.1)
# Generate Bolean Values based on which col == min value
min.value <- min.e.dist == e.dist.vector
c.assignments <- function(df.d){
'Input:     data frame that includes data + dist to centroids
Output:    same data frame w/ a new col with centroid assignments'
# Get Number of Cols (necessary as we need to tell the program how many centroids were gen)
num.cols <- length(df.d[1,])
# Isolate col/vector w/ distance measure to each centroid
e.dist.vector <- df.d[1, 3: num.cols]
# Get the Min Distance (essentially the min value of this vector)
min.e.dist <- min(e.dist.vector)
# Generate Bolean Values based on which col == min value
min.value <- min.e.dist == e.dist.vector
# Iterate vector to identify which centroid has the min dist
col.name.min.value <- get.col.name(min.value)
print(paste('Column w/ min dist value =', col.name.min.value))
# Return Value
}
# Isolate col/vector w/ distance measure to each centroid
e.dist.vector <- df.d[1, 3: num.cols]
test.1 <- head(df.d.c.dist)
c.assignments(test.1)
get.col.name <- function(min.value.matrix){
'Input:    min.value is a matrix.  Convert to df
Output:   col name w/ min e.dist value'
df.min.value <- data.frame(min.value.matrix)
count = 0
col.num = ''
for (i in df.min.value){
print(i)
count = count+1
# Identify Col == True
if (i == TRUE){
# Assign i value to col.num
col.num = i
}
}
return(paste('c.', col.num))
}
get.col.name <- function(min.value.matrix){
'Input:    min.value is a matrix.  Convert to df
Output:   col name w/ min e.dist value'
df.min.value <- data.frame(min.value.matrix)
count = 0
col.num = ''
for (i in df.min.value){
print(i)
count = count+1
# Identify Col == True
if (i == TRUE){
# Assign i value to col.num
col.num = count
}
}
return(paste('c.', col.num))
}
get.col.name <- function(min.value.matrix){
'Input:    min.value is a matrix.  Convert to df
Output:   col name w/ min e.dist value'
df.min.value <- data.frame(min.value.matrix)
count = 0
col.num = ''
for (i in df.min.value){
print(i)
count = count+1
# Identify Col == True
if (i == TRUE){
# Assign i value to col.num
col.num = count
}
}
return(paste('c.', col.num, sep=''))
}
c.assignments <- function(df.d){
'Input:     data frame that includes data + dist to centroids
Output:    same data frame w/ a new col with centroid assignments'
# Get Number of Cols (necessary as we need to tell the program how many centroids were gen)
num.cols <- length(df.d[1,])
# Isolate col/vector w/ distance measure to each centroid
e.dist.vector <- df.d[1, 3: num.cols]
# Get the Min Distance (essentially the min value of this vector)
min.e.dist <- min(e.dist.vector)
# Generate Bolean Values based on which col == min value
min.value <- min.e.dist == e.dist.vector
# Iterate vector to identify which centroid has the min dist
col.name.min.value <- get.col.name(min.value)
print(paste('Column w/ min dist value =', col.name.min.value))
# Return Value
}
test.1 <- head(df.d.c.dist)
c.assignments(test.1)
# Create Empty Vector to House Our Assignments
c.assignment.vector <- c()
